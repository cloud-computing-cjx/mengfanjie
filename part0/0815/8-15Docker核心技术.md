# 作业
## A.思考题: 容器的劣势有哪些？
### 隔离性
基于 hypervisor 的虚机技术，在隔离性上比容器技术要更好，它们的系统硬件资源完全是虚拟化的，当一台虚机出现系统级别的问题，往往不会蔓延到同一宿主机上的其他虚机。但是容器就不一样了，容器之间共享同一个操作系统内核以及其他组件，所以在收到攻击之类的情况发生时，更容易通过底层操作系统影响到其他容器。当然，这个问题可以通过在虚机中部署容器来解决，可是这样又会引出新的问题，比如成本的增加以及下面要提到的问题：性能。
### 性能
不管是虚机还是容器，都是运用不同的技术，对应用本身进行了一定程度的封装和隔离，在降低应用和应用之间以及应用和环境之间的耦合性上做了很多努力，但是随机而来的，就会产生更多的网络连接转发以及数据交互，这在低并发系统上表现不会太明显，而且往往不会成为一个应用的瓶颈（可能会分散于不同的虚机或者服务器上），但是当同一虚机或者服务器下面的容器需要更高并发量支撑的时候，也就是并发问题成为应用瓶颈的时候，容器会将这个问题放大，所以，并不是所有的应用场景都是适用于容器技术的。
### 存储方案
容器的诞生并不是为OS抽象服务的，这是它和虚机最大的区别，这样的基因意味着容器天生是为应用环境做更多的努力，容器的伸缩也是基于容器的这一disposable特性，而与之相对的，需要持久化存储方案恰恰相反。这一点docker容器提供的解决方案是利用volume接口形成数据的映射和转移，以实现数据持久化的目的。但是这样同样也会造成一部分资源的浪费和更多交互的发生，不管是映射到宿主机上还是到网络磁盘，都是退而求其次的解决方案。
### 资源开销
Docker由于宿主机上的所有容器是共享相同的内核和相同的资源，如果对某些资源（CPU、内存、磁盘等）的访问不受限制，那么异常的容器将占用整个宿主机的资源，从而影响其他容器的运行，影响应用程序。
### 内核漏洞
Docker内核攻击对于容器化环境来说可能是致命性的，因为容器与主机共享相同的系统内核，因此单独信任容器内置保护机制是不够的。

容器的隔离性使得某个应用程序的漏洞不会直接影响到其他容器的应用程序，但是漏洞可能会破坏与其他容器所共享的单一的操作系统，进而影响机器上的其他容器。如果漏洞允许代码执行，那么它将在主机操作系统上执行，而不是在容器内执行；如果此漏洞允许任意内存访问，则攻击者可以更改或读取任何其他容器的任何数据。
### 数据分离
在docker容器上，有一些非命名空间的资源：
```
SELinux
Cgroups
file systems under /sys, /proc/sys,
/proc/sysrq-trigger, /proc/irq, /proc/bus
/dev/mem, /dev/sd* file system
Kernel Modules
```
如果攻击者可以利用当中的任意一个元素，都将拥有主机系统的操作权限。
### 套接字问题
容器在默认情况下都安装了docker Unix套接字（/var/run/docker.sock），此套接字，可以关闭、启动或者创建新的镜像。

当你的容器启动并共享套接字的时候，你就给了容器操控宿主机的权限，它将可以启动或终止其它容器，在宿主机拖入或创建镜像，甚至写入到宿主机的文件系统。正确配置和保护，可以使用docker容器实现高级别的安全性，但它的安全性还是低于正确配置的VM。
## B.实验题: 使用memory进行限制
### 创建目录并进入
```
cd /sys/fs/cgroup/memory && mkdir memorydemo && cd memorydemo
```
### 运行malloc程序
```
cd /bigdata/git-projects/cloud/CloudNative/mengfanjie/golang/examples/malloc
make build
./malloc
```
### 查看内存使用情况
```
watch 'ps -aux|grep malloc|grep -v grep'
```
### 通过 cgroup 限制 memory
#### 把进程添加到 cgroup 进程配置组
```
# pwd
/sys/fs/cgroup/memory/memorydemo

echo ps -ef|grep malloc |grep -v grep|awk '{print $2}' > cgroup.procs
```
#### 设置 memory.limit_in_bytes
```
echo 104960000 > memory.limit_in_bytes
```